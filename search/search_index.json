{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 This documentation is about the 2.x branch of the library (alpha stage!). This project brings Pandoc 's data model for markdown documents to Python: $ echo \"Hello world!\" | python -m pandoc read Pandoc(Meta({}), [Para([Str('Hello'), Space(), Str('world!')])]) It can be used to analyze, create and transform documents, in Python : >>> import pandoc >>> text = \"Hello world!\" >>> doc = pandoc.read(text) >>> doc Pandoc(Meta({}), [Para([Str('Hello'), Space(), Str('world!')])]) >>> paragraph = doc[1][0] >>> paragraph Para([Str('Hello'), Space(), Str('world!')]) >>> from pandoc.types import Str >>> paragraph[0][2] = Str('Python!') >>> text = pandoc.write(doc) >>> print(text) # doctest: +NORMALIZE_WHITESPACE Hello Python! Pandoc is the general markup converter (and Haskell library) written by John MacFarlane .","title":"Overview"},{"location":"#overview","text":"This documentation is about the 2.x branch of the library (alpha stage!). This project brings Pandoc 's data model for markdown documents to Python: $ echo \"Hello world!\" | python -m pandoc read Pandoc(Meta({}), [Para([Str('Hello'), Space(), Str('world!')])]) It can be used to analyze, create and transform documents, in Python : >>> import pandoc >>> text = \"Hello world!\" >>> doc = pandoc.read(text) >>> doc Pandoc(Meta({}), [Para([Str('Hello'), Space(), Str('world!')])]) >>> paragraph = doc[1][0] >>> paragraph Para([Str('Hello'), Space(), Str('world!')]) >>> from pandoc.types import Str >>> paragraph[0][2] = Str('Python!') >>> text = pandoc.write(doc) >>> print(text) # doctest: +NORMALIZE_WHITESPACE Hello Python! Pandoc is the general markup converter (and Haskell library) written by John MacFarlane .","title":"Overview"},{"location":"api/","text":"API Reference \u00b6","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"configuration/","text":"Configuration \u00b6 Introduction \u00b6 The good news are that you generally don't need to configure anything: when you use the pandoc Python library, it does inspect your system to find the available pandoc command-line tool and configures itself accordingly. Most of the time, this is what you want. However, if you need more control on this configuration step, you can import pandoc and call configure before you do anything else with the library: import pandoc pandoc.configure(...) If you do this, the implicit configuration does not take place; it is triggered only when no configuration is specified when you import pandoc.types or you call pandoc.read or pandoc.write . Options \u00b6 To have the library find a pandoc executable in your path, and configure itself accordingly, enable the auto option pandoc.configure(auto=True) This is the method used by the implicit configuration. If instead you want to specify manually the pandoc executable, use the path argument, for example: pandoc.configure(path='/usr/bin/pandoc') Some features 1 of the Python pandoc library do not require the pandoc executable, but in this case we still need to know what version of pandoc you target, so specify for example: pandoc.configure(version='1.16.0.2') Actually, the exact version of pandoc is not even required. Instead what matters is the version of the document model that you intend to use, or equivalently, the version of the pandoc-types Haskell package used by the pandoc executable. Accordingly, you may configure pandoc with the pandoc_types_version argument: pandoc.configure(pandoc_types_version='1.16.1.1') Extra Arguments \u00b6 To get a copy of the configuration (or None if the library is not configured yet), enable the read option. The call pandoc.configure(read=True) does not change the current configuration but returns a dictionary whose keys are auto , path , version and pandoc_types_version , such as { 'auto': True, 'path': '/usr/bin/pandoc', 'version': '1.16.0.2', 'pandoc_types_version': '1.16.1.1' } The read option may be combined with other arguments, for example config = pandoc.configure(auto=True, read=True) This is actually a good way to know where the pandoc executable has been found, what is its version and the corresponding version of pandoc-types . When it is needed, it is also possible to restore the unconfigured state: pandoc.configure(reset=True) typically conversion between json and Python object representations of documents and analysis or transformations of documents as Python objects. As soon as you use convert to or from any other format, markdown for example, you need a pandoc executable. \u21a9","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#introduction","text":"The good news are that you generally don't need to configure anything: when you use the pandoc Python library, it does inspect your system to find the available pandoc command-line tool and configures itself accordingly. Most of the time, this is what you want. However, if you need more control on this configuration step, you can import pandoc and call configure before you do anything else with the library: import pandoc pandoc.configure(...) If you do this, the implicit configuration does not take place; it is triggered only when no configuration is specified when you import pandoc.types or you call pandoc.read or pandoc.write .","title":"Introduction"},{"location":"configuration/#options","text":"To have the library find a pandoc executable in your path, and configure itself accordingly, enable the auto option pandoc.configure(auto=True) This is the method used by the implicit configuration. If instead you want to specify manually the pandoc executable, use the path argument, for example: pandoc.configure(path='/usr/bin/pandoc') Some features 1 of the Python pandoc library do not require the pandoc executable, but in this case we still need to know what version of pandoc you target, so specify for example: pandoc.configure(version='1.16.0.2') Actually, the exact version of pandoc is not even required. Instead what matters is the version of the document model that you intend to use, or equivalently, the version of the pandoc-types Haskell package used by the pandoc executable. Accordingly, you may configure pandoc with the pandoc_types_version argument: pandoc.configure(pandoc_types_version='1.16.1.1')","title":"Options"},{"location":"configuration/#extra-arguments","text":"To get a copy of the configuration (or None if the library is not configured yet), enable the read option. The call pandoc.configure(read=True) does not change the current configuration but returns a dictionary whose keys are auto , path , version and pandoc_types_version , such as { 'auto': True, 'path': '/usr/bin/pandoc', 'version': '1.16.0.2', 'pandoc_types_version': '1.16.1.1' } The read option may be combined with other arguments, for example config = pandoc.configure(auto=True, read=True) This is actually a good way to know where the pandoc executable has been found, what is its version and the corresponding version of pandoc-types . When it is needed, it is also possible to restore the unconfigured state: pandoc.configure(reset=True) typically conversion between json and Python object representations of documents and analysis or transformations of documents as Python objects. As soon as you use convert to or from any other format, markdown for example, you need a pandoc executable. \u21a9","title":"Extra Arguments"},{"location":"document/","text":"Document \u00b6 Use the new metaclass-based representation to drive an exploration of the document model. Link to the proper documentation when needed, or use exemple from markdown text to see what every construct is about. Explore an existing document or create from scratch? First explore, then build from scratch? Explain that the person willing to analyze/transform documents has to understand how each (or some of the) document pieces are represented? And that it's what we try to do here? >>> import pandoc >>> from pandoc.types import * >>> text = \"Hello, World!\" >>> doc = pandoc.read(text) >>> doc Pandoc(Meta({}), [Para([Str('Hello,'), Space(), Str('World!')])]) A document is an instance of the Pandoc class; it has two arguments >>> Pandoc Pandoc(Meta, [Block]) The first argument, the instance of Meta , represents the document metadata. Since in this very simple example there is no metadata, we will ignore it and focus on the second argument instead, the document contents, which is a list of blocks: >>> blocks = doc[1] >>> blocks [Para([Str('Hello,'), Space(), Str('World!')])] Actually, there is a single block here >>> len(blocks) 1 There are several possible types of blocks: headers, paragraphs, lists, etc. >>> Block Block = Plain([Inline]) | Para([Inline]) | LineBlock([[Inline]]) | CodeBlock(Attr, Text) | RawBlock(Format, Text) | BlockQuote([Block]) | OrderedList(ListAttributes, [[Block]]) | BulletList([[Block]]) | DefinitionList([([Inline], [[Block]])]) | Header(Int, Attr, [Inline]) | HorizontalRule() | Table([Inline], [Alignment], [Double], [TableCell], [[TableCell]]) | Div(Attr, [Block]) | Null() Here our single block is a paragraph: >>> para = blocks[0] >>> para Para([Str('Hello,'), Space(), Str('World!')]) >>> isinstance(para, Para) True In general, paragraphs contain lists of inline elements: >>> Para Para([Inline]) >>> inlines = para[0] Inlines can be several things: ordinary text, emphasized text, strong text, etc. >>> Inline Inline = Str(Text) | Emph([Inline]) | Strong([Inline]) | Strikeout([Inline]) | Superscript([Inline]) | Subscript([Inline]) | SmallCaps([Inline]) | Quoted(QuoteType, [Inline]) | Cite([Citation], [Inline]) | Code(Attr, Text) | Space() | SoftBreak() | LineBreak() | Math(MathType, Text) | RawInline(Format, Text) | Link(Attr, [Inline], Target) | Image(Attr, [Inline], Target) | Note([Block]) | Span(Attr, [Inline]) Here we simply have a mixture of ordinary text and space. >>> inlines = para[0] >>> inlines [Str('Hello,'), Space(), Str('World!')] Instances of Space have no argument while instances of Str contain a text Text >>> Space Space() >>> Str Str(Text) >>> Text == type(u\"\") True Finally >>> print(inlines[0][0] + \" \" + inlines[2][0]) Hello, World!","title":"Document"},{"location":"document/#document","text":"Use the new metaclass-based representation to drive an exploration of the document model. Link to the proper documentation when needed, or use exemple from markdown text to see what every construct is about. Explore an existing document or create from scratch? First explore, then build from scratch? Explain that the person willing to analyze/transform documents has to understand how each (or some of the) document pieces are represented? And that it's what we try to do here? >>> import pandoc >>> from pandoc.types import * >>> text = \"Hello, World!\" >>> doc = pandoc.read(text) >>> doc Pandoc(Meta({}), [Para([Str('Hello,'), Space(), Str('World!')])]) A document is an instance of the Pandoc class; it has two arguments >>> Pandoc Pandoc(Meta, [Block]) The first argument, the instance of Meta , represents the document metadata. Since in this very simple example there is no metadata, we will ignore it and focus on the second argument instead, the document contents, which is a list of blocks: >>> blocks = doc[1] >>> blocks [Para([Str('Hello,'), Space(), Str('World!')])] Actually, there is a single block here >>> len(blocks) 1 There are several possible types of blocks: headers, paragraphs, lists, etc. >>> Block Block = Plain([Inline]) | Para([Inline]) | LineBlock([[Inline]]) | CodeBlock(Attr, Text) | RawBlock(Format, Text) | BlockQuote([Block]) | OrderedList(ListAttributes, [[Block]]) | BulletList([[Block]]) | DefinitionList([([Inline], [[Block]])]) | Header(Int, Attr, [Inline]) | HorizontalRule() | Table([Inline], [Alignment], [Double], [TableCell], [[TableCell]]) | Div(Attr, [Block]) | Null() Here our single block is a paragraph: >>> para = blocks[0] >>> para Para([Str('Hello,'), Space(), Str('World!')]) >>> isinstance(para, Para) True In general, paragraphs contain lists of inline elements: >>> Para Para([Inline]) >>> inlines = para[0] Inlines can be several things: ordinary text, emphasized text, strong text, etc. >>> Inline Inline = Str(Text) | Emph([Inline]) | Strong([Inline]) | Strikeout([Inline]) | Superscript([Inline]) | Subscript([Inline]) | SmallCaps([Inline]) | Quoted(QuoteType, [Inline]) | Cite([Citation], [Inline]) | Code(Attr, Text) | Space() | SoftBreak() | LineBreak() | Math(MathType, Text) | RawInline(Format, Text) | Link(Attr, [Inline], Target) | Image(Attr, [Inline], Target) | Note([Block]) | Span(Attr, [Inline]) Here we simply have a mixture of ordinary text and space. >>> inlines = para[0] >>> inlines [Str('Hello,'), Space(), Str('World!')] Instances of Space have no argument while instances of Str contain a text Text >>> Space Space() >>> Str Str(Text) >>> Text == type(u\"\") True Finally >>> print(inlines[0][0] + \" \" + inlines[2][0]) Hello, World!","title":"Document"},{"location":"elements/","text":"Elements \u00b6 >>> import pandoc >>> from pandoc.types import * Helpers \u00b6 We introduce a simple function to display pandoc elements in markdown: >>> def display(elt): ... print(pandoc.write(elt)) We also define a to function to to get a specific type of element inside a document: >>> def to(elt, type): ... for _elt in pandoc.iter(elt): ... if isinstance(_elt, type): ... return _elt Since we're a bit reckless, we monkey-patch the pandoc type base class to use to as a method: >>> Type.to = to Paragraphs \u00b6 Headers \u00b6 Quotations \u00b6 Code Blocks \u00b6 Line Blocks \u00b6 Lists \u00b6 Horizontal Rules \u00b6 Tables \u00b6 Reference: Pandoc User's Guide / Tables Simple tables in markdown typically look like this: >>> text = \"\"\" ... Right Left Center Default ... ------- ------ ---------- ------- ... 12 12 12 12 ... 123 123 123 123 ... 1 1 1 1 ... --------------------------------------- ... ... Table: Demonstration of simple table syntax. ... \"\"\" A table is defined by 5 arguments: >>> Table Table([Inline], [Alignment], [Double], [TableCell], [[TableCell]]) They define respectively the table caption, column alignments, column widths, headers and rows. The most important are the last two, headers and rows. Headers are described by a list of table cells: it's the content of first table row. The last argument refers to the remaining table rows, each row being described as a list of table cells. The content of a table cell can be arbitrarily complex: anything that can be used in a document content (except for the metadata) can be used in a table cell. Actually, TableCell is not a new type, but an alias for \"list of blocks\": >>> TableCell TableCell = [Block] Let's have a look at the attributes of the table above: >>> doc = pandoc.read(text) >>> table = doc.to(Table) >>> caption, alignments, widths, headers, rows = table[:] Here are the column headers: >>> headers [[Plain([Str('Right')])], [Plain([Str('Left')])], [Plain([Str('Center')])], [Plain([Str('Default')])]] >>> for cell in headers: ... display(cell) Right <BLANKLINE> Left <BLANKLINE> Center <BLANKLINE> Default <BLANKLINE> The structure of rows are similar. For example, we can display the contents of the first row: >>> rows [[[Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])]], [[Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])]], [[Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])]]] >>> first_row = rows[0] >>> for cell in first_row: ... display(cell) 12 <BLANKLINE> 12 <BLANKLINE> 12 <BLANKLINE> 12 <BLANKLINE> The three other table arguments are caption, column alignments and column widths. Caption is the obvious one: it's the content of the (optional) table caption, described as a list of inlines: >>> caption [Str('Demonstration'), Space(), Str('of'), Space(), Str('simple'), Space(), Str('table'), Space(), Str('syntax.')] Column alignments is a list of alignment options, among the four possible choices below: >>> Alignment Alignment = AlignLeft() | AlignRight() | AlignCenter() | AlignDefault() In the current table, the four kinds are effectively used: >>> alignments [AlignRight(), AlignLeft(), AlignCenter(), AlignDefault()] The third argument is a list of floating-point numbers which are fractions of 1 and determine the column widths. Either their sum is one of they are all set to zero, in which vase the attribute carries no information. Here, we are in this default case: >>> widths [0.0, 0.0, 0.0, 0.0] Column widths are relevant in the context of multiline tables (see Pandoc User's Guide / Tables ) that look like this: >>> text = \"\"\" ... ------------------------------------------------------------- ... Centered Default Right Left ... Header Aligned Aligned Aligned ... ----------- ------- --------------- ------------------------- ... First row 12.0 Example of a row that ... spans multiple lines. ... ... Second row 5.0 Here's another one. Note ... the blank line between ... rows. ... ------------------------------------------------------------- ... ... Table: Here's the caption. It, too, may span ... multiple lines. ... \"\"\" For this multiline table, the table parser computes the relative column widths: >>> table = pandoc.read(text).to(Table) >>> _, _, widths, _, _ = table[:] >>> widths [0.16666666666666666, 0.1111111111111111, 0.2222222222222222, 0.3611111111111111] Now, since the last column has a lot of content and the third one has plenty of empty space, we could select relative widths to narrow the third column and enlarge the last one. Here is how that looks: >>> table[2] = [1/6, 1/9, 1/9, 5/12] # the sum is 1.0 >>> display(table) ------------------------------------------------------------- Centered Default Right Left Aligned Header Aligned Aligned ----------- --------- --------- ----------------------------- First row 12.0 Example of a row that spans multiple lines. <BLANKLINE> Second row 5.0 Here's another one. Note the blank line between rows. ------------------------------------------------------------- <BLANKLINE> : Here's the caption. It, too, may span multiple lines. <BLANKLINE> Of course, it is possible to create tables programmatically: Example: Multiplication Table We show how to build a multiplication table. First, we decide the size of the table: here we will compute products up to 5x5: >>> n = 5 We won't need any caption, are ok with the default column alignments and don't specify explicitly the column widths: >>> caption = [] >>> alignments = n * [AlignDefault()] >>> widths = n * [0.0] Now, since the structure of a table cell in pandoc is so general, it may be a bit cumbersome when the content is so simple. To ease this pain, we define a small cell function which creates a table cell that wraps some arbitrary text-like content. >>> def cell(text): ... inline = Str(str(text)) ... blocks = [Plain([inline])] ... return blocks Now we may define the table headers >>> headers = [cell(\"x\")] >>> for j in range(1, n+1): ... headers.append(cell(j)) and rows >>> rows = [] >>> for i in range(1, n+1): ... row = [cell(i)] ... for j in range(1, n+1): ... row.append(cell(i * j)) ... rows.append(row) The final table is: >>> table = Table(caption, alignments, widths, headers, rows) >>> display(table) x 1 2 3 4 5 --- --- ---- ---- ---- ---- 1 1 2 3 4 5 2 2 4 6 8 10 3 3 6 9 12 15 4 4 8 12 16 20 5 5 10 15 20 25 <BLANKLINE> Inline Formatting \u00b6 LaTeX and Math \u00b6 HTML \u00b6 Links \u00b6 Images \u00b6 Divs and Spans \u00b6 Footnotes \u00b6 Citations \u00b6 Metadata \u00b6 Reference: Pandoc User's Guide / Metadata Blocks TODO. Start with document without metadata, then simple title and contents, then more advanced metadata ... and finally YAML blocks? TODO: specify use cases: use for custom templates, misc. configuration options (e.g. stylesheets, EPUB metadata, bibliography, etc.) >>> Meta Meta({Text: MetaValue}) ... >>> MetaValue MetaValue = MetaMap({Text: MetaValue}) | MetaList([MetaValue]) | MetaBool(Bool) | MetaString(Text) | MetaInlines([Inline]) | MetaBlocks([Block]) ... >>> text = \"\"\"\\ ... % Document Title ... % Author One, Author Two ... % Date ... \"\"\" ... >>> doc = pandoc.read(text) >>> doc == \\ ... Pandoc( ... Meta(map([ ... ('date', MetaInlines([Str('Date')])), ... ('author', MetaList([MetaInlines( ... [Str('Author'), Space(), Str('One,'), Space(), Str('Author'), Space(), Str('Two')])])), ... ('title', MetaInlines([Str('Document'), Space(), Str('Title')])) ... ])), ... [] ... ) True ... >>> metadata = doc[0][0] >>> metadata[\"title\"] MetaInlines([Str('Document'), Space(), Str('Title')]) >>> metadata[\"author\"] MetaList([MetaInlines([Str('Author'), Space(), Str('One,'), Space(), Str('Author'), Space(), Str('Two')])]) >>> metadata[\"date\"] MetaInlines([Str('Date')]) TODO: discuss simple vs general (YAML) syntax. TODO: explain goals: simple doc metadata + \"compiler\" / template directives + any kind of user-defined goals. TODO: parsing: when MetaInlines, when MetaBlocks? Test stuff, read code. Also distinguish MetaString vs MetaInlines ... (ex: '42': there is no number type allowed in pandoc metadata). TODO: check if order in maps is preserved in markdown to JSON repr (I think I remember it is not). Well, the spec tells us mappings are not ordered, so we're good here. Apparently, there is a compact notation to represent ordered mappings as lists of unordered mappings with a single entry (OK, I can see how that plays: you just prefix every key with - ) Code Analysis. Pandoc metadata reading code: Source on GitHub handling is in the yamlMetaBlock function the YAML text to YAML structure is mostly delegated to the Data.YAML library the translation from the Data.YAML YAML item representation to the Meta stuff of pandoc is managed by yamlToMeta . There everything is mostly simple and unsurprising (maybe except for a little micro management of numbers, but well, ok: floats that are integers are \"integerized\"). The real deal is the management of strings, delegated to toMetaValue . Note that only numbers (and NULL / empty) are returned as MetaStrings , strings are not. toMetaValue : AFAICT: if the strings ends with a newline, it's some blocks, otherwise it's some inline. The easiest way to get some blocks is to use So to get a block, you can use in particular any folded or literal style (see stack overflow . Essentially folded won't remember the linebreak at all while the literal style will remember them as soft breaks. Nota: \"normal\" multiline strings won't get a newline so they won't be reconized as blocks. If they contain newlines, it will be recognized as a simple softbreak. Nota: adding a newline at the end of a quoted string does not trigger MetaBlocks. Why? Is it somehow in the spec of YAML that strip such strings? Well, ok, let's accept that at face value. TODO: Nota: round-tripping is not stable here: start with say the YAML metadata block: --- a: '42' --- The stuff gets parsed as MetaInlines; but write it again (in standalone mode) and you get 42 without the quotes, that gets parsed as MetaString instead. So, well, if we end up with a sorta weakly typed representation, we should not worry too much since in some respect pandoc management of this metadata is kinda weak anyway. OR you can argue that the behavior above is a bug. But actually, there is no way to know what the original type was, no the arbitrary serialization can hardly be objected ... right? Another round-tripping issue. MetaBlocks may be serialized without as 'normal' strings, not blocks, so if they are parsed again, they will be considered MetaInlines. This one suck badly and can be considered to be a bug. You need something like at least two blocks to be serialized as a block? I have to have a look at the markdown writer (but, well, it may be hidden in the YAML library code, not clear I can explicit the issue with pandoc's code only). There, the metadata if first converted to a JSON-like structure before being cast to YAML (search for metaToJSON ). The JSON stuff knows shit about how the strings has been specified so this is where the stuff goes bad? Is the newline content somehow preserved in this translation at least? And is jsonToYaml taking that into account? Yeah, well jsonToYaml is using literal stuff all right if there is a newline in the string. So the issue is above, to check that metaToJSON does its job properly ... the bug should be there. And metaToJSON is here . Well actually blockListToMarkdown and blockToMarkdown may be the functions to investigate. Is blockListToMarkdown missing a trailing newline (at least in the context of it use in metaToJSON ? Fuck, I cannot grok this code in reasonable time, just log an issue with the example. TODO: to and from \"naked\" yaml / json ? Discuss ambiguity (empty stuff essentially? Then we don't know if we have lists or inlines or blocks, that's about it right?). Pragmatic approach (without bugfix): cast everything to strings and promote to blocks if it contains (or ends with?) a newline? Shit: adding a linebreak to MetaBlocks serializes some shit? Like a \\ at the end of string (which is still not a block).","title":"Elements"},{"location":"elements/#elements","text":">>> import pandoc >>> from pandoc.types import *","title":"Elements"},{"location":"elements/#helpers","text":"We introduce a simple function to display pandoc elements in markdown: >>> def display(elt): ... print(pandoc.write(elt)) We also define a to function to to get a specific type of element inside a document: >>> def to(elt, type): ... for _elt in pandoc.iter(elt): ... if isinstance(_elt, type): ... return _elt Since we're a bit reckless, we monkey-patch the pandoc type base class to use to as a method: >>> Type.to = to","title":"Helpers"},{"location":"elements/#paragraphs","text":"","title":"Paragraphs"},{"location":"elements/#headers","text":"","title":"Headers"},{"location":"elements/#quotations","text":"","title":"Quotations"},{"location":"elements/#code-blocks","text":"","title":"Code Blocks"},{"location":"elements/#line-blocks","text":"","title":"Line Blocks"},{"location":"elements/#lists","text":"","title":"Lists"},{"location":"elements/#horizontal-rules","text":"","title":"Horizontal Rules"},{"location":"elements/#tables","text":"Reference: Pandoc User's Guide / Tables Simple tables in markdown typically look like this: >>> text = \"\"\" ... Right Left Center Default ... ------- ------ ---------- ------- ... 12 12 12 12 ... 123 123 123 123 ... 1 1 1 1 ... --------------------------------------- ... ... Table: Demonstration of simple table syntax. ... \"\"\" A table is defined by 5 arguments: >>> Table Table([Inline], [Alignment], [Double], [TableCell], [[TableCell]]) They define respectively the table caption, column alignments, column widths, headers and rows. The most important are the last two, headers and rows. Headers are described by a list of table cells: it's the content of first table row. The last argument refers to the remaining table rows, each row being described as a list of table cells. The content of a table cell can be arbitrarily complex: anything that can be used in a document content (except for the metadata) can be used in a table cell. Actually, TableCell is not a new type, but an alias for \"list of blocks\": >>> TableCell TableCell = [Block] Let's have a look at the attributes of the table above: >>> doc = pandoc.read(text) >>> table = doc.to(Table) >>> caption, alignments, widths, headers, rows = table[:] Here are the column headers: >>> headers [[Plain([Str('Right')])], [Plain([Str('Left')])], [Plain([Str('Center')])], [Plain([Str('Default')])]] >>> for cell in headers: ... display(cell) Right <BLANKLINE> Left <BLANKLINE> Center <BLANKLINE> Default <BLANKLINE> The structure of rows are similar. For example, we can display the contents of the first row: >>> rows [[[Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])], [Plain([Str('12')])]], [[Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])], [Plain([Str('123')])]], [[Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])], [Plain([Str('1')])]]] >>> first_row = rows[0] >>> for cell in first_row: ... display(cell) 12 <BLANKLINE> 12 <BLANKLINE> 12 <BLANKLINE> 12 <BLANKLINE> The three other table arguments are caption, column alignments and column widths. Caption is the obvious one: it's the content of the (optional) table caption, described as a list of inlines: >>> caption [Str('Demonstration'), Space(), Str('of'), Space(), Str('simple'), Space(), Str('table'), Space(), Str('syntax.')] Column alignments is a list of alignment options, among the four possible choices below: >>> Alignment Alignment = AlignLeft() | AlignRight() | AlignCenter() | AlignDefault() In the current table, the four kinds are effectively used: >>> alignments [AlignRight(), AlignLeft(), AlignCenter(), AlignDefault()] The third argument is a list of floating-point numbers which are fractions of 1 and determine the column widths. Either their sum is one of they are all set to zero, in which vase the attribute carries no information. Here, we are in this default case: >>> widths [0.0, 0.0, 0.0, 0.0] Column widths are relevant in the context of multiline tables (see Pandoc User's Guide / Tables ) that look like this: >>> text = \"\"\" ... ------------------------------------------------------------- ... Centered Default Right Left ... Header Aligned Aligned Aligned ... ----------- ------- --------------- ------------------------- ... First row 12.0 Example of a row that ... spans multiple lines. ... ... Second row 5.0 Here's another one. Note ... the blank line between ... rows. ... ------------------------------------------------------------- ... ... Table: Here's the caption. It, too, may span ... multiple lines. ... \"\"\" For this multiline table, the table parser computes the relative column widths: >>> table = pandoc.read(text).to(Table) >>> _, _, widths, _, _ = table[:] >>> widths [0.16666666666666666, 0.1111111111111111, 0.2222222222222222, 0.3611111111111111] Now, since the last column has a lot of content and the third one has plenty of empty space, we could select relative widths to narrow the third column and enlarge the last one. Here is how that looks: >>> table[2] = [1/6, 1/9, 1/9, 5/12] # the sum is 1.0 >>> display(table) ------------------------------------------------------------- Centered Default Right Left Aligned Header Aligned Aligned ----------- --------- --------- ----------------------------- First row 12.0 Example of a row that spans multiple lines. <BLANKLINE> Second row 5.0 Here's another one. Note the blank line between rows. ------------------------------------------------------------- <BLANKLINE> : Here's the caption. It, too, may span multiple lines. <BLANKLINE> Of course, it is possible to create tables programmatically: Example: Multiplication Table We show how to build a multiplication table. First, we decide the size of the table: here we will compute products up to 5x5: >>> n = 5 We won't need any caption, are ok with the default column alignments and don't specify explicitly the column widths: >>> caption = [] >>> alignments = n * [AlignDefault()] >>> widths = n * [0.0] Now, since the structure of a table cell in pandoc is so general, it may be a bit cumbersome when the content is so simple. To ease this pain, we define a small cell function which creates a table cell that wraps some arbitrary text-like content. >>> def cell(text): ... inline = Str(str(text)) ... blocks = [Plain([inline])] ... return blocks Now we may define the table headers >>> headers = [cell(\"x\")] >>> for j in range(1, n+1): ... headers.append(cell(j)) and rows >>> rows = [] >>> for i in range(1, n+1): ... row = [cell(i)] ... for j in range(1, n+1): ... row.append(cell(i * j)) ... rows.append(row) The final table is: >>> table = Table(caption, alignments, widths, headers, rows) >>> display(table) x 1 2 3 4 5 --- --- ---- ---- ---- ---- 1 1 2 3 4 5 2 2 4 6 8 10 3 3 6 9 12 15 4 4 8 12 16 20 5 5 10 15 20 25 <BLANKLINE>","title":"Tables"},{"location":"elements/#inline-formatting","text":"","title":"Inline Formatting"},{"location":"elements/#latex-and-math","text":"","title":"LaTeX and Math"},{"location":"elements/#html","text":"","title":"HTML"},{"location":"elements/#links","text":"","title":"Links"},{"location":"elements/#images","text":"","title":"Images"},{"location":"elements/#divs-and-spans","text":"","title":"Divs and Spans"},{"location":"elements/#footnotes","text":"","title":"Footnotes"},{"location":"elements/#citations","text":"","title":"Citations"},{"location":"elements/#metadata","text":"Reference: Pandoc User's Guide / Metadata Blocks TODO. Start with document without metadata, then simple title and contents, then more advanced metadata ... and finally YAML blocks? TODO: specify use cases: use for custom templates, misc. configuration options (e.g. stylesheets, EPUB metadata, bibliography, etc.) >>> Meta Meta({Text: MetaValue}) ... >>> MetaValue MetaValue = MetaMap({Text: MetaValue}) | MetaList([MetaValue]) | MetaBool(Bool) | MetaString(Text) | MetaInlines([Inline]) | MetaBlocks([Block]) ... >>> text = \"\"\"\\ ... % Document Title ... % Author One, Author Two ... % Date ... \"\"\" ... >>> doc = pandoc.read(text) >>> doc == \\ ... Pandoc( ... Meta(map([ ... ('date', MetaInlines([Str('Date')])), ... ('author', MetaList([MetaInlines( ... [Str('Author'), Space(), Str('One,'), Space(), Str('Author'), Space(), Str('Two')])])), ... ('title', MetaInlines([Str('Document'), Space(), Str('Title')])) ... ])), ... [] ... ) True ... >>> metadata = doc[0][0] >>> metadata[\"title\"] MetaInlines([Str('Document'), Space(), Str('Title')]) >>> metadata[\"author\"] MetaList([MetaInlines([Str('Author'), Space(), Str('One,'), Space(), Str('Author'), Space(), Str('Two')])]) >>> metadata[\"date\"] MetaInlines([Str('Date')]) TODO: discuss simple vs general (YAML) syntax. TODO: explain goals: simple doc metadata + \"compiler\" / template directives + any kind of user-defined goals. TODO: parsing: when MetaInlines, when MetaBlocks? Test stuff, read code. Also distinguish MetaString vs MetaInlines ... (ex: '42': there is no number type allowed in pandoc metadata). TODO: check if order in maps is preserved in markdown to JSON repr (I think I remember it is not). Well, the spec tells us mappings are not ordered, so we're good here. Apparently, there is a compact notation to represent ordered mappings as lists of unordered mappings with a single entry (OK, I can see how that plays: you just prefix every key with - ) Code Analysis. Pandoc metadata reading code: Source on GitHub handling is in the yamlMetaBlock function the YAML text to YAML structure is mostly delegated to the Data.YAML library the translation from the Data.YAML YAML item representation to the Meta stuff of pandoc is managed by yamlToMeta . There everything is mostly simple and unsurprising (maybe except for a little micro management of numbers, but well, ok: floats that are integers are \"integerized\"). The real deal is the management of strings, delegated to toMetaValue . Note that only numbers (and NULL / empty) are returned as MetaStrings , strings are not. toMetaValue : AFAICT: if the strings ends with a newline, it's some blocks, otherwise it's some inline. The easiest way to get some blocks is to use So to get a block, you can use in particular any folded or literal style (see stack overflow . Essentially folded won't remember the linebreak at all while the literal style will remember them as soft breaks. Nota: \"normal\" multiline strings won't get a newline so they won't be reconized as blocks. If they contain newlines, it will be recognized as a simple softbreak. Nota: adding a newline at the end of a quoted string does not trigger MetaBlocks. Why? Is it somehow in the spec of YAML that strip such strings? Well, ok, let's accept that at face value. TODO: Nota: round-tripping is not stable here: start with say the YAML metadata block: --- a: '42' --- The stuff gets parsed as MetaInlines; but write it again (in standalone mode) and you get 42 without the quotes, that gets parsed as MetaString instead. So, well, if we end up with a sorta weakly typed representation, we should not worry too much since in some respect pandoc management of this metadata is kinda weak anyway. OR you can argue that the behavior above is a bug. But actually, there is no way to know what the original type was, no the arbitrary serialization can hardly be objected ... right? Another round-tripping issue. MetaBlocks may be serialized without as 'normal' strings, not blocks, so if they are parsed again, they will be considered MetaInlines. This one suck badly and can be considered to be a bug. You need something like at least two blocks to be serialized as a block? I have to have a look at the markdown writer (but, well, it may be hidden in the YAML library code, not clear I can explicit the issue with pandoc's code only). There, the metadata if first converted to a JSON-like structure before being cast to YAML (search for metaToJSON ). The JSON stuff knows shit about how the strings has been specified so this is where the stuff goes bad? Is the newline content somehow preserved in this translation at least? And is jsonToYaml taking that into account? Yeah, well jsonToYaml is using literal stuff all right if there is a newline in the string. So the issue is above, to check that metaToJSON does its job properly ... the bug should be there. And metaToJSON is here . Well actually blockListToMarkdown and blockToMarkdown may be the functions to investigate. Is blockListToMarkdown missing a trailing newline (at least in the context of it use in metaToJSON ? Fuck, I cannot grok this code in reasonable time, just log an issue with the example. TODO: to and from \"naked\" yaml / json ? Discuss ambiguity (empty stuff essentially? Then we don't know if we have lists or inlines or blocks, that's about it right?). Pragmatic approach (without bugfix): cast everything to strings and promote to blocks if it contains (or ends with?) a newline? Shit: adding a linebreak to MetaBlocks serializes some shit? Like a \\ at the end of string (which is still not a block).","title":"Metadata"},{"location":"examples/","text":"TODO: plain text (no image, no link, no div, not attribute, etc.). Now that attributes & divs are captured from HTML, it can become VERY noisy, a filter like that could alleviate the problem. Test it on pandoc's web site for example? This is interesting, we will have to 'flatten' the divs. At least get rid of everything that smells too much HTML (link may be ok?), like raw html & divs. Wait there is no raw html in this case right? Get rid of it anyway. Examples \u00b6 >>> import pandoc >>> from pandoc.types import * >>> def T(function): ... def _f(markdown): ... doc = pandoc.read(markdown) ... _doc = function(doc) ... if _doc is not None: ... doc = _doc ... print(pandoc.write(doc)) ... return _f Uppercase \u00b6 >>> def capitalize(doc): ... for elt in pandoc.iter(doc): ... if isinstance(elt, Str): ... elt[0] = elt[0].upper() >>> T(capitalize)(\"I can't feel my legs\") I CAN'T FEEL MY LEGS <BLANKLINE> TODO: extra NEWLINE in the output, solve this. OR maybe this is to be expected? A doc DOES END with a newline? See what pandoc does about this. De-emphasize \u00b6 TODO: think of the pattern: if something matches a condition, replace it with something (and stop the iteration in this branch? Or iterate on the new object?). Pandoc-filters has the ability to let the \"atomic transformation\" control the rest of the iteration by calling walk. See how this is done, study walk. >>> def capitalize(doc): ... for elt in pandoc.iter(doc): ... if isinstance(elt, Str): ... elt[0] = elt[0].upper() >>> T(capitalize)(\"I can't feel my legs\") I CAN'T FEEL MY LEGS <BLANKLINE> TODO: extra NEWLINE in the output, solve this. OR maybe this is to be expected? A doc DOES END with a newline? See what pandoc does about this. Comments \u00b6 Remove everything between <!-- BEGIN COMMENT --> and <!-- END COMMENT --> . The comment lines must appear on lines by themselves, with blank lines surrounding them. TODO: find HTML RawBlocks, check for start/end markers, remove the items within. TODO: these scheme may fail with tuples right? Improve the \"Block holder\" detection. >>> def begin_comment(elt): ... return isinstance(elt, RawBlock) and \\ ... elt[0] == Format(u\"html\") and \\ ... \"<!-- BEGIN COMMENT -->\" in elt[1] ... >>> def end_comment(elt): ... return isinstance(elt, RawBlock) and \\ ... elt[0] == Format(u\"html\") and \\ ... \"<!-- END COMMENT -->\" in elt[1] And now >>> def ignore_comments(doc): ... for elt in pandoc.iter(doc): ... if isinstance(elt, list) and len(elt) > 0 and isinstance(elt[0], Block): ... children = [] ... in_comment = False ... for child in elt[:]: ... if begin_comment(child): ... in_comment = True ... elif end_comment(child): ... in_comment = False ... else: ... if not in_comment: ... children.append(child) ... elt[:] = children Leads to >>> markdown = \"\"\"\\ ... Regular text ... ... <!-- BEGIN COMMENT --> ... A comment ... ... <!-- END COMMENT --> ... Moar regular text ... \"\"\" >>> T(ignore_comments)(markdown) Regular text <BLANKLINE> Moar regular text <BLANKLINE> Theorems \u00b6 Convert divs with class=\"theorem\" to LaTeX theorem environments in LaTeX output, and to numbered theorems in HTML output. TODO: to HTML version. Also export to LaTeX and HTML to see the outputs? Can it be done with an option to the T function? TODO: think of some support for visitor patterns? We see a lot of \"do this in-place if this condition is met\". Or can we use the basic pandoc map/filter? Dunno. Think of it. Arf with filter or map we have to deal with linearized data types? We can linearize but can we reassemble. How are filter and map used for hierarchial structures in functional programming? Have a look at Haskell (e.g. https://stackoverflow.com/questions/7624774/haskell-map-for-trees ). So, define a pandoc.map helper? >>> def is_theorem(elt): ... if isinstance(elt, Div): ... attrs = elt[0] ... _, classes, _ = attrs ... if \"theorem\" in classes: ... return True ... return False >>> def LaTeX(text): ... return RawBlock(Format('latex'), text) >>> def theorem_latex(doc): ... for elt in pandoc.iter(doc): ... if is_theorem(elt): ... id_ = elt[0][0] ... label = \"\" ... if id_: ... label = r'\\label{' + id_ + '}' ... start_theorem = LaTeX(r'\\begin{theorem}' + label) ... end_theorem = LaTeX(r'\\end{theorem}') ... elt[1][:] = [start_theorem] + elt[1] + [end_theorem] >>> markdown = r\"\"\" ... I'd like to introduce the following theorem: ... <div id='cauchy-formula' class='theorem'> ... $$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$ ... </div> ... Right? ... \"\"\" >>> T(theorem_latex)(markdown) I'd like to introduce the following theorem: <BLANKLINE> ::: {#cauchy-formula .theorem} ```{=latex} \\begin{theorem}\\label{cauchy-formula} ``` $$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$ <BLANKLINE> ```{=latex} \\end{theorem} ``` ::: <BLANKLINE> Right? <BLANKLINE> Notebooks \u00b6 http://nbformat.readthedocs.io/en/latest/format_description.html#the-notebook-file-format #!/usr/bin/env python # Python Standard Library import copy import json import os.path import sys # Pandoc import pandoc def Notebook(): return copy.deepcopy( { \"cells\": [], \"metadata\": { \"kernelspec\": { \"display_name\": \"Python 3\", \"language\": \"python\", \"name\": \"python3\" }, \"language_info\": { \"codemirror_mode\": { \"name\": \"ipython\", \"version\": 3 }, \"file_extension\": \".py\", \"mimetype\": \"text/x-python\", \"name\": \"python\", \"nbconvert_exporter\": \"python\", \"pygments_lexer\": \"ipython3\", \"version\": \"3.6.4\" } }, \"nbformat\": 4, \"nbformat_minor\": 2 } ) def CodeCell(): return copy.deepcopy( { \"cell_type\": \"code\", \"execution_count\": 1, \"metadata\": {}, \"outputs\": [], \"source\": [] } ) def MarkdownCell(): return copy.deepcopy( { \"cell_type\": \"markdown\", \"metadata\": {}, \"source\": [] } ) def notebookify(doc): from pandoc.types import Pandoc, Meta, CodeBlock notebook = Notebook() cells = notebook['cells'] blocks = doc[1] #print(blocks) execution_count = 1 for block in blocks: if isinstance(block, CodeBlock): source = block[1] code_cell = CodeCell() code_cell['source'] = source code_cell['execution_count'] = execution_count execution_count += 1 cells.append(code_cell) else: wrapper = Pandoc(Meta({}), [block]) #print(wrapper) source = pandoc.write(wrapper) markdown_cell = MarkdownCell() markdown_cell['source'] = source cells.append(markdown_cell) return notebook if __name__ == '__main__': filename = sys.argv[1] doc = pandoc.read(file=filename) notebook = notebookify(doc) base, _ = os.path.splitext(filename) output = open(base + '.ipynb', 'w') output.write(json.dumps(notebook, indent=2)) output.close() Save Web Documents \u00b6 When you find an interesting piece of content on the Web, you may want to archive it on your computer. Since you are only interested in the content and not the full web page, there are things in the HTML document that you want probably want to remove in the process (ads, social media, etc.). And while you're at it, why not store the result as Markdown, which is a simpler document description language? We know that thanks to pandoc, we can convert it to something fancy like PDF if the need arises. Consider for example the \"Getting started\" section of the the pandoc documentation. This is a useful document, I want to keep a copy of it in my hard drive. Downloading it and converting it to Markdown is easy: $ curl https://pandoc.org/getting-started.html > getting-started.html $ pandoc -o getting-started.md getting-started.html However, when you look at the result, this is very \"noisy\". Its starts with ::: {#doc .container-fluid} ::: {#flattr} [](https://pandoc.org){.FlattrButton} [![Flattr this](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc) ::: ::: {#paypal} ![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\" height=\"1\"} ::: [Pandoc]{.big} [a universal document converter]{.small} ::: {#bd} ::: {.navbar-header} [Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar} ::: ::: {.navbar-collapse .collapse} - [About](index.html) - [Installing](installing.html) - ... ::: ::: {.col-md-9 .col-sm-8 role=\"main\"} ::: {.row} ::: {#toc} - [Step 1: Install pandoc](#step-1-install-pandoc) - [Step 2: Open a terminal](#step-2-open-a-terminal) - ... ::: There are two different kind of things here: a \"div soup\", characterized by the sheer number of ::: symbols 1 . In pandoc-flavored Markdown, the ::: syntax corresponds to the <div> tag in HTML. Div hierarchies are often used to style HTML elements, so this is something that we don't need anymore. components that don't make sense out of the web page: some buttons, a navigation bar, etc. It's only after this long and noisy preamble that you find the real content. It looks like this: This document is for people who are unfamiliar with command line tools. Command-line experts can go straight to the [User's Guide](README.html) or the pandoc man page. Step 1: Install pandoc ====================== First, install pandoc, following the [instructions for your platform](installing.html). Step 2: Open a terminal ======================= ... And finally, you close the four divs in which the content is nested: ::: ::: ::: ::: This is probably not the document that you want to store. To simplify it, we are going to remove all the hierarchy of divs and get rid of the preamble. Unpack Divs \u00b6 def unpack_divs(doc): \"Unpack Divs - Two-pass, In-Place Algorithm\" # Locate the divs and extract the relevant data matches = [] for elt, path in pandoc.iter(doc, path=True): if isinstance(elt, Div): div = elt parent, index = path[-1] contents = div[1] # Blocks are always held in lists (cf. the document model). assert isinstance(parent, list) matches.append((parent, index, contents)) # We need to unpack the divs in reverse document order # not to invalidate the remaining matches. for parent, index, contents in reversed(matches): del parent[index] parent[index:index] = contents return doc Unpack Divs (Variant) \u00b6 You may find that the approach above is convoluted. It's actually perfectly possible to achieve the same transformation in one pass if we build a new document instead of modifying the original. This is best achieved using recursion. To get a feeling how recursion can be used to create modified copies of a document, we can first implement a copy without modification: def copy(elt): \"Copy the document (or document fragment) recursively\" # List, tuple, map and (non-primitive) Pandoc types if hasattr(elt, \"__iter__\") and not isinstance(elt, String): type_ = type(elt) if type_ is map: args = list(elt.items()) else: args = elt[:] new_args = [copy(arg) for arg in args] if issubclass(type_, (list, tuple, map)): return type_(new_args) else: # Pandoc types return type_(*new_args) else: # Python atomic (immutable) types return elt Note that the name of the function argument is not doc but elt since the copy function may be used with any document fragment, not merely with a document. Let's go back to our original problem, which is div unpacking. Since divs are held in lists of blocks, we define a predicate that identifies lists of blocks: def is_blocks(elt): \"Identify (non-empty) lists of blocks\" return isinstance(elt, list) and \\ len(elt)!=0 and \\ isinstance(elt[0], Block) And now we are ready to define the alternate implementation of unpack_div . First, we detect when elt is a list of blocks and in this case, if some of these blocks are divs, we expand them: def unpack_divs(elt): \"Unpack Divs - One-Pass, Recursive, Non-Destructive Algorithm\" # Find the list of blocks and their div children and unpack them if is_blocks(elt): blocks = elt new_blocks = [] for block in blocks: if isinstance(block, Div): div = block contents = div[1] new_blocks.extend(unpack_divs(contents)) else: new_blocks.append(unpack_divs(block)) assert not any([isinstance(block, Div) for block in new_blocks]) return new_blocks We also need to handle the remaining cases, but this is easy since this is similar to what the recursive copy is doing: # List, tuple, map and (non-primitive) Pandoc types elif hasattr(elt, \"__iter__\") and not isinstance(elt, String): type_ = type(elt) if type_ is map: args = list(elt.items()) else: args = elt[:] new_args = [unpack_divs(arg) for arg in args] if issubclass(type_, (list, tuple, map)): return type_(new_args) else: # Pandoc types return type_(*new_args) else: # Python atomic (immutable) types return elt Remove The Preamble \u00b6 At this stage, if you wrap any of the unpack_divs into # file: simplify.py if __name__ == \"__main__\": url = 'https://pandoc.org/getting-started.html' src = urllib.request.urlopen(url).read() doc = pandoc.read(src, format=\"html\") doc = unpack_divs(doc) print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"])) This is what you get when you execute the script: $ python simplify.py --- lang: en title: 'Pandoc - Getting started with pandoc' viewport: 'width=device-width, initial-scale=1.0' --- [](https://pandoc.org){.FlattrButton} [![Flattr this](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc) ![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\" height=\"1\"} [Pandoc]{.big} [a universal document converter]{.small} [Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar} - [About](index.html) - [Installing](installing.html) - ... - [Step 1: Install pandoc](#step-1-install-pandoc) - [Step 2: Open a terminal](#step-2-open-a-terminal) - ... This document is for people who are unfamiliar with command line tools. Command-line experts can go straight to the [User's Guide](README.html) or the pandoc man page. Step 1: Install pandoc ====================== First, install pandoc, following the [instructions for your platform](installing.html). Step 2: Open a terminal ======================= ... If you get stuck, you can always ask questions on the [pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing list. But be sure to check the [FAQs](faqs.html) first, and search through the mailing list to see if your question has been answered before. This is better, since there is no more div, but we still need to get rid of everything before the first real paragraph, the one that starts with some plain text: \"This document ...\". So we can detect this first paragraph \u2013 for example because it starts with an instance of Str \u2013 and remove everything before it from the document: def remove_preamble(doc): \"Remove everything before the first real paragraph\" blocks = doc[1] for i, block in enumerate(blocks): if isinstance(block, Para): para = block inlines = para[0] if len(inlines) > 0 and isinstance(inlines[0], Str): break doc[1] = blocks[i:] return doc Now, change the main entry point accordingly: # file: simplify.py if __name__ == \"__main__\": url = 'https://pandoc.org/getting-started.html' src = urllib.request.urlopen(url).read() doc = pandoc.read(src, format=\"html\") doc = unpack_divs(doc) doc = remove_preamble(doc) print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"])) and this is what you get: $ python simplify.py --- lang: en title: 'Pandoc - Getting started with pandoc' viewport: 'width=device-width, initial-scale=1.0' --- This document is for people who are unfamiliar with command line tools. Command-line experts can go straight to the [User's Guide](README.html) or the pandoc man page. Step 1: Install pandoc ====================== First, install pandoc, following the [instructions for your platform](installing.html). Step 2: Open a terminal ======================= ... If you get stuck, you can always ask questions on the [pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing list. But be sure to check the [FAQs](faqs.html) first, and search through the mailing list to see if your question has been answered before. Mission accomplished! We could also disable the native_divs option in pandoc to get rid of the div soup, but where would be the fun then? \u21a9","title":"Examples"},{"location":"examples/#examples","text":">>> import pandoc >>> from pandoc.types import * >>> def T(function): ... def _f(markdown): ... doc = pandoc.read(markdown) ... _doc = function(doc) ... if _doc is not None: ... doc = _doc ... print(pandoc.write(doc)) ... return _f","title":"Examples"},{"location":"examples/#uppercase","text":">>> def capitalize(doc): ... for elt in pandoc.iter(doc): ... if isinstance(elt, Str): ... elt[0] = elt[0].upper() >>> T(capitalize)(\"I can't feel my legs\") I CAN'T FEEL MY LEGS <BLANKLINE> TODO: extra NEWLINE in the output, solve this. OR maybe this is to be expected? A doc DOES END with a newline? See what pandoc does about this.","title":"Uppercase"},{"location":"examples/#de-emphasize","text":"TODO: think of the pattern: if something matches a condition, replace it with something (and stop the iteration in this branch? Or iterate on the new object?). Pandoc-filters has the ability to let the \"atomic transformation\" control the rest of the iteration by calling walk. See how this is done, study walk. >>> def capitalize(doc): ... for elt in pandoc.iter(doc): ... if isinstance(elt, Str): ... elt[0] = elt[0].upper() >>> T(capitalize)(\"I can't feel my legs\") I CAN'T FEEL MY LEGS <BLANKLINE> TODO: extra NEWLINE in the output, solve this. OR maybe this is to be expected? A doc DOES END with a newline? See what pandoc does about this.","title":"De-emphasize"},{"location":"examples/#comments","text":"Remove everything between <!-- BEGIN COMMENT --> and <!-- END COMMENT --> . The comment lines must appear on lines by themselves, with blank lines surrounding them. TODO: find HTML RawBlocks, check for start/end markers, remove the items within. TODO: these scheme may fail with tuples right? Improve the \"Block holder\" detection. >>> def begin_comment(elt): ... return isinstance(elt, RawBlock) and \\ ... elt[0] == Format(u\"html\") and \\ ... \"<!-- BEGIN COMMENT -->\" in elt[1] ... >>> def end_comment(elt): ... return isinstance(elt, RawBlock) and \\ ... elt[0] == Format(u\"html\") and \\ ... \"<!-- END COMMENT -->\" in elt[1] And now >>> def ignore_comments(doc): ... for elt in pandoc.iter(doc): ... if isinstance(elt, list) and len(elt) > 0 and isinstance(elt[0], Block): ... children = [] ... in_comment = False ... for child in elt[:]: ... if begin_comment(child): ... in_comment = True ... elif end_comment(child): ... in_comment = False ... else: ... if not in_comment: ... children.append(child) ... elt[:] = children Leads to >>> markdown = \"\"\"\\ ... Regular text ... ... <!-- BEGIN COMMENT --> ... A comment ... ... <!-- END COMMENT --> ... Moar regular text ... \"\"\" >>> T(ignore_comments)(markdown) Regular text <BLANKLINE> Moar regular text <BLANKLINE>","title":"Comments"},{"location":"examples/#theorems","text":"Convert divs with class=\"theorem\" to LaTeX theorem environments in LaTeX output, and to numbered theorems in HTML output. TODO: to HTML version. Also export to LaTeX and HTML to see the outputs? Can it be done with an option to the T function? TODO: think of some support for visitor patterns? We see a lot of \"do this in-place if this condition is met\". Or can we use the basic pandoc map/filter? Dunno. Think of it. Arf with filter or map we have to deal with linearized data types? We can linearize but can we reassemble. How are filter and map used for hierarchial structures in functional programming? Have a look at Haskell (e.g. https://stackoverflow.com/questions/7624774/haskell-map-for-trees ). So, define a pandoc.map helper? >>> def is_theorem(elt): ... if isinstance(elt, Div): ... attrs = elt[0] ... _, classes, _ = attrs ... if \"theorem\" in classes: ... return True ... return False >>> def LaTeX(text): ... return RawBlock(Format('latex'), text) >>> def theorem_latex(doc): ... for elt in pandoc.iter(doc): ... if is_theorem(elt): ... id_ = elt[0][0] ... label = \"\" ... if id_: ... label = r'\\label{' + id_ + '}' ... start_theorem = LaTeX(r'\\begin{theorem}' + label) ... end_theorem = LaTeX(r'\\end{theorem}') ... elt[1][:] = [start_theorem] + elt[1] + [end_theorem] >>> markdown = r\"\"\" ... I'd like to introduce the following theorem: ... <div id='cauchy-formula' class='theorem'> ... $$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$ ... </div> ... Right? ... \"\"\" >>> T(theorem_latex)(markdown) I'd like to introduce the following theorem: <BLANKLINE> ::: {#cauchy-formula .theorem} ```{=latex} \\begin{theorem}\\label{cauchy-formula} ``` $$f(z) = \\frac{1}{i2\\pi} \\int \\frac{f(w){w-z}\\, dw$$ <BLANKLINE> ```{=latex} \\end{theorem} ``` ::: <BLANKLINE> Right? <BLANKLINE>","title":"Theorems"},{"location":"examples/#notebooks","text":"http://nbformat.readthedocs.io/en/latest/format_description.html#the-notebook-file-format #!/usr/bin/env python # Python Standard Library import copy import json import os.path import sys # Pandoc import pandoc def Notebook(): return copy.deepcopy( { \"cells\": [], \"metadata\": { \"kernelspec\": { \"display_name\": \"Python 3\", \"language\": \"python\", \"name\": \"python3\" }, \"language_info\": { \"codemirror_mode\": { \"name\": \"ipython\", \"version\": 3 }, \"file_extension\": \".py\", \"mimetype\": \"text/x-python\", \"name\": \"python\", \"nbconvert_exporter\": \"python\", \"pygments_lexer\": \"ipython3\", \"version\": \"3.6.4\" } }, \"nbformat\": 4, \"nbformat_minor\": 2 } ) def CodeCell(): return copy.deepcopy( { \"cell_type\": \"code\", \"execution_count\": 1, \"metadata\": {}, \"outputs\": [], \"source\": [] } ) def MarkdownCell(): return copy.deepcopy( { \"cell_type\": \"markdown\", \"metadata\": {}, \"source\": [] } ) def notebookify(doc): from pandoc.types import Pandoc, Meta, CodeBlock notebook = Notebook() cells = notebook['cells'] blocks = doc[1] #print(blocks) execution_count = 1 for block in blocks: if isinstance(block, CodeBlock): source = block[1] code_cell = CodeCell() code_cell['source'] = source code_cell['execution_count'] = execution_count execution_count += 1 cells.append(code_cell) else: wrapper = Pandoc(Meta({}), [block]) #print(wrapper) source = pandoc.write(wrapper) markdown_cell = MarkdownCell() markdown_cell['source'] = source cells.append(markdown_cell) return notebook if __name__ == '__main__': filename = sys.argv[1] doc = pandoc.read(file=filename) notebook = notebookify(doc) base, _ = os.path.splitext(filename) output = open(base + '.ipynb', 'w') output.write(json.dumps(notebook, indent=2)) output.close()","title":"Notebooks"},{"location":"examples/#save-web-documents","text":"When you find an interesting piece of content on the Web, you may want to archive it on your computer. Since you are only interested in the content and not the full web page, there are things in the HTML document that you want probably want to remove in the process (ads, social media, etc.). And while you're at it, why not store the result as Markdown, which is a simpler document description language? We know that thanks to pandoc, we can convert it to something fancy like PDF if the need arises. Consider for example the \"Getting started\" section of the the pandoc documentation. This is a useful document, I want to keep a copy of it in my hard drive. Downloading it and converting it to Markdown is easy: $ curl https://pandoc.org/getting-started.html > getting-started.html $ pandoc -o getting-started.md getting-started.html However, when you look at the result, this is very \"noisy\". Its starts with ::: {#doc .container-fluid} ::: {#flattr} [](https://pandoc.org){.FlattrButton} [![Flattr this](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc) ::: ::: {#paypal} ![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\" height=\"1\"} ::: [Pandoc]{.big} [a universal document converter]{.small} ::: {#bd} ::: {.navbar-header} [Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar} ::: ::: {.navbar-collapse .collapse} - [About](index.html) - [Installing](installing.html) - ... ::: ::: {.col-md-9 .col-sm-8 role=\"main\"} ::: {.row} ::: {#toc} - [Step 1: Install pandoc](#step-1-install-pandoc) - [Step 2: Open a terminal](#step-2-open-a-terminal) - ... ::: There are two different kind of things here: a \"div soup\", characterized by the sheer number of ::: symbols 1 . In pandoc-flavored Markdown, the ::: syntax corresponds to the <div> tag in HTML. Div hierarchies are often used to style HTML elements, so this is something that we don't need anymore. components that don't make sense out of the web page: some buttons, a navigation bar, etc. It's only after this long and noisy preamble that you find the real content. It looks like this: This document is for people who are unfamiliar with command line tools. Command-line experts can go straight to the [User's Guide](README.html) or the pandoc man page. Step 1: Install pandoc ====================== First, install pandoc, following the [instructions for your platform](installing.html). Step 2: Open a terminal ======================= ... And finally, you close the four divs in which the content is nested: ::: ::: ::: ::: This is probably not the document that you want to store. To simplify it, we are going to remove all the hierarchy of divs and get rid of the preamble.","title":"Save Web Documents"},{"location":"examples/#unpack-divs","text":"def unpack_divs(doc): \"Unpack Divs - Two-pass, In-Place Algorithm\" # Locate the divs and extract the relevant data matches = [] for elt, path in pandoc.iter(doc, path=True): if isinstance(elt, Div): div = elt parent, index = path[-1] contents = div[1] # Blocks are always held in lists (cf. the document model). assert isinstance(parent, list) matches.append((parent, index, contents)) # We need to unpack the divs in reverse document order # not to invalidate the remaining matches. for parent, index, contents in reversed(matches): del parent[index] parent[index:index] = contents return doc","title":"Unpack Divs"},{"location":"examples/#unpack-divs-variant","text":"You may find that the approach above is convoluted. It's actually perfectly possible to achieve the same transformation in one pass if we build a new document instead of modifying the original. This is best achieved using recursion. To get a feeling how recursion can be used to create modified copies of a document, we can first implement a copy without modification: def copy(elt): \"Copy the document (or document fragment) recursively\" # List, tuple, map and (non-primitive) Pandoc types if hasattr(elt, \"__iter__\") and not isinstance(elt, String): type_ = type(elt) if type_ is map: args = list(elt.items()) else: args = elt[:] new_args = [copy(arg) for arg in args] if issubclass(type_, (list, tuple, map)): return type_(new_args) else: # Pandoc types return type_(*new_args) else: # Python atomic (immutable) types return elt Note that the name of the function argument is not doc but elt since the copy function may be used with any document fragment, not merely with a document. Let's go back to our original problem, which is div unpacking. Since divs are held in lists of blocks, we define a predicate that identifies lists of blocks: def is_blocks(elt): \"Identify (non-empty) lists of blocks\" return isinstance(elt, list) and \\ len(elt)!=0 and \\ isinstance(elt[0], Block) And now we are ready to define the alternate implementation of unpack_div . First, we detect when elt is a list of blocks and in this case, if some of these blocks are divs, we expand them: def unpack_divs(elt): \"Unpack Divs - One-Pass, Recursive, Non-Destructive Algorithm\" # Find the list of blocks and their div children and unpack them if is_blocks(elt): blocks = elt new_blocks = [] for block in blocks: if isinstance(block, Div): div = block contents = div[1] new_blocks.extend(unpack_divs(contents)) else: new_blocks.append(unpack_divs(block)) assert not any([isinstance(block, Div) for block in new_blocks]) return new_blocks We also need to handle the remaining cases, but this is easy since this is similar to what the recursive copy is doing: # List, tuple, map and (non-primitive) Pandoc types elif hasattr(elt, \"__iter__\") and not isinstance(elt, String): type_ = type(elt) if type_ is map: args = list(elt.items()) else: args = elt[:] new_args = [unpack_divs(arg) for arg in args] if issubclass(type_, (list, tuple, map)): return type_(new_args) else: # Pandoc types return type_(*new_args) else: # Python atomic (immutable) types return elt","title":"Unpack Divs (Variant)"},{"location":"examples/#remove-the-preamble","text":"At this stage, if you wrap any of the unpack_divs into # file: simplify.py if __name__ == \"__main__\": url = 'https://pandoc.org/getting-started.html' src = urllib.request.urlopen(url).read() doc = pandoc.read(src, format=\"html\") doc = unpack_divs(doc) print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"])) This is what you get when you execute the script: $ python simplify.py --- lang: en title: 'Pandoc - Getting started with pandoc' viewport: 'width=device-width, initial-scale=1.0' --- [](https://pandoc.org){.FlattrButton} [![Flattr this](https://api.flattr.com/button/flattr-badge-large.png \"Flattr this\")](https://flattr.com/thing/936364/Pandoc) ![](https://www.paypalobjects.com/en_US/i/scr/pixel.gif){width=\"1\" height=\"1\"} [Pandoc]{.big} [a universal document converter]{.small} [Toggle navigation]{.sr-only} []{.icon-bar} []{.icon-bar} []{.icon-bar} - [About](index.html) - [Installing](installing.html) - ... - [Step 1: Install pandoc](#step-1-install-pandoc) - [Step 2: Open a terminal](#step-2-open-a-terminal) - ... This document is for people who are unfamiliar with command line tools. Command-line experts can go straight to the [User's Guide](README.html) or the pandoc man page. Step 1: Install pandoc ====================== First, install pandoc, following the [instructions for your platform](installing.html). Step 2: Open a terminal ======================= ... If you get stuck, you can always ask questions on the [pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing list. But be sure to check the [FAQs](faqs.html) first, and search through the mailing list to see if your question has been answered before. This is better, since there is no more div, but we still need to get rid of everything before the first real paragraph, the one that starts with some plain text: \"This document ...\". So we can detect this first paragraph \u2013 for example because it starts with an instance of Str \u2013 and remove everything before it from the document: def remove_preamble(doc): \"Remove everything before the first real paragraph\" blocks = doc[1] for i, block in enumerate(blocks): if isinstance(block, Para): para = block inlines = para[0] if len(inlines) > 0 and isinstance(inlines[0], Str): break doc[1] = blocks[i:] return doc Now, change the main entry point accordingly: # file: simplify.py if __name__ == \"__main__\": url = 'https://pandoc.org/getting-started.html' src = urllib.request.urlopen(url).read() doc = pandoc.read(src, format=\"html\") doc = unpack_divs(doc) doc = remove_preamble(doc) print(pandoc.write(doc, format=\"markdown\", options=[\"-s\"])) and this is what you get: $ python simplify.py --- lang: en title: 'Pandoc - Getting started with pandoc' viewport: 'width=device-width, initial-scale=1.0' --- This document is for people who are unfamiliar with command line tools. Command-line experts can go straight to the [User's Guide](README.html) or the pandoc man page. Step 1: Install pandoc ====================== First, install pandoc, following the [instructions for your platform](installing.html). Step 2: Open a terminal ======================= ... If you get stuck, you can always ask questions on the [pandoc-discuss](http://groups.google.com/group/pandoc-discuss) mailing list. But be sure to check the [FAQs](faqs.html) first, and search through the mailing list to see if your question has been answered before. Mission accomplished! We could also disable the native_divs option in pandoc to get rid of the div soup, but where would be the fun then? \u21a9","title":"Remove The Preamble"},{"location":"iteration/","text":"Iteration \u00b6 Need to explain direct access beforehand. So the \"iteration\" title is not appropriate ? Go for \"Indexing and Iteration ?\". Mmmm ... TODO : [:] or for in vs iter (children vs descendants) iter (examples, use NORMALIZE_WHITESPACE when appropriate) iter manages dicts (and strings) differently, explain explain path iteration and info.","title":"Iteration"},{"location":"iteration/#iteration","text":"Need to explain direct access beforehand. So the \"iteration\" title is not appropriate ? Go for \"Indexing and Iteration ?\". Mmmm ... TODO : [:] or for in vs iter (children vs descendants) iter (examples, use NORMALIZE_WHITESPACE when appropriate) iter manages dicts (and strings) differently, explain explain path iteration and info.","title":"Iteration"}]}